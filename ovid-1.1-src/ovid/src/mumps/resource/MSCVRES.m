MSCVRES	; MSC/JDA - Resource message format ; SEP 28, 2010 22:00:00
 ;;1.0;OpenVista Interface Domain;**1500**;May 14, 2009
 ;
FROMBYTE(RETVAL,BYTES)	;
 S RETVAL("ROOT")=$$GETROOT()
 M @RETVAL("ROOT")=BYTES
 Q
TOBYTE(RETVAL,RES)	;
 M RETVAL=@RES("ROOT")
 K RETVAL("INDEX")
 K RETVAL("OFFSET")
 K RETVAL("PROP")
 K RETVAL("VAL")
 Q
TOGLOBAL(RETVAL,RES)	;
 S RETVAL=RES("ROOT")
 K RES("ROOT")
 Q
DISPOSE(RES)	;
 K:$G(RES("ROOT"))'="" @RES("ROOT")
 K RES
 Q
START(RES)	; for write
 S RES("INDEX")=1,RES("OFFSET")=1
 S RES("ROOT")=$$GETROOT()
 S @RES("ROOT")@(1)=""
 Q
FIRST(RES)	; for read
 S RES("INDEX")=1,RES("OFFSET")=1,RES("PROP")="",RES("VAL")=""
 Q
GETBYTES(RES,NUM)	;
 N RETVAL
 N NXTLNAMT S NXTLNAMT=0 ; Number of bytes to get from the next line
 ; CHUNK_SIZE is 201
 N OFFSET S OFFSET=RES("OFFSET")
 N INDEX S INDEX=RES("INDEX")
 I NUM+OFFSET-1>201 S NXTLNAMT=NUM+OFFSET-201-1 S NUM=201-OFFSET+1
 S RETVAL=$E(@RES("ROOT")@(INDEX),OFFSET,OFFSET+NUM-1)
 S RES("OFFSET")=OFFSET+NUM
 I RES("OFFSET")=(201+1) S RES("OFFSET")=1 S RES("INDEX")=INDEX+1
 S:NXTLNAMT>0 RETVAL=RETVAL_$$GETBYTES(.RES,NXTLNAMT)
 Q RETVAL
PUTBYTES(RES,BYTES)	;
 N LEN S LEN=$L(BYTES)
 N NUM S NUM=LEN
 ; CHUNK_SIZE is 201
 N OFFSET S OFFSET=RES("OFFSET")
 N INDEX S INDEX=RES("INDEX")
 I NUM+OFFSET-1>201 S NUM=201-OFFSET+1 S @RES("ROOT")@(INDEX)=@RES("ROOT")@(INDEX)_$E(BYTES,1,NUM)
 E  S @RES("ROOT")@(INDEX)=(@RES("ROOT")@(INDEX))_BYTES
 S RES("OFFSET")=OFFSET+NUM
 I RES("OFFSET")=(201+1) S RES("OFFSET")=1 S RES("INDEX")=INDEX+1 S @RES("ROOT")@(INDEX+1)=""
 D:NUM'=LEN PUTBYTES(.RES,$E(BYTES,NUM+1,LEN))
 Q
B64TOINT(BUFFER)	;
 N IDX,RESULT
 N CHAR64 S CHAR64="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
 S RESULT=0
 F IDX=1:1:$L(BUFFER) D
 . S RESULT=(RESULT*64)+$F(CHAR64,$E(BUFFER,IDX))-2 ; arrays are 1-base, and find return one past, so +2
 . Q
 Q RESULT
DECODINT(RES,NUMBYTES)	;
 N BUFFER
 S BUFFER=$RE($$GETBYTES(.RES,NUMBYTES))
 Q $$B64TOINT(BUFFER)
ENCODINT(SIZE,NUMBYTES)	;
 N ENCODED,IDX S ENCODED=""
 N CHAR64 S CHAR64="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
 F IDX=1:1:NUMBYTES D
 . S ENCODED=ENCODED_$E(CHAR64,(SIZE#64)+1)
 . S SIZE=SIZE\64
 . Q
 Q ENCODED
NEXTPROP(RES)	;
 N SIZE S SIZE=$$DECODINT(.RES,1)
 I SIZE=0 S RES("PROP")="",RES("VAL")="" Q 0
 S RES("PROP")=$$GETBYTES(.RES,SIZE)
 S SIZE=$$DECODINT(.RES,2)
 S RES("VAL")=$S(SIZE=0:"",1:$$GETBYTES(.RES,SIZE))
 Q 1
GETPROP(RES)	;
 Q RES("PROP")
GETVAL(RES)	;
 Q RES("VAL")
ENCODSTR(STR,NUMBYTES)	;
 Q $$ENCODINT($L(STR),NUMBYTES)_STR
ADDCMPD(RES,NAME)	;
 D PUTBYTES(.RES,$$ENCODSTR(NAME,1)_$$ENCODINT(0,2))
 Q
ENDCMPD(RES)	;
 D PUTBYTES(.RES,$$ENCODINT(0,1))
 Q
ADDPROP(RES,NAME,VAL)	;
 Q:VAL=""  ; Empty values would be confused with compounds
 D PUTBYTES(.RES,$$ENCODSTR(NAME,1)_$$ENCODSTR(VAL,2))
 Q
READBUF(LEN)	;
 N RETVAL,REMAIN,TMP
 S REMAIN=LEN
 S RETVAL=""
 F  Q:REMAIN=0  D
 . R TMP#REMAIN:60
 . S RETVAL=RETVAL_TMP
 . S REMAIN=LEN-$L(RETVAL)
 Q RETVAL
SAVEIO	;
 I '($D(IO)#2) D
 . N VAR
 . F VAR="IO","IO(0)","IOBS","IOF","IOM","ION","IOS","IOSL","IOST","IOST(0)","IOT","IOXY" K @VAR
 . D HOME^%ZIS
 D SAVDEV^%ZISUTL("oldio")
 Q
LOADIO	;
 D USE^%ZISUTL("oldio")
 D RMDEV^%ZISUTL("oldio")
 Q
USE(SOCK)	;
 D USE^%ZISUTL(SOCK("S"))
 Q
GETSOCK(SOCK,IPADDR,PORT,TO)	;
 N SOCKNUM
 S SOCKNUM=$O(^TMP("MSCVRES",$J,""),-1)
 S:SOCKNUM="" SOCKNUM=0
 S SOCKNUM=SOCKNUM+1
 S ^TMP("MSCVRES",$J,SOCKNUM)=""
 D SAVEIO
 D CALL^%ZISTCP(IPADDR,PORT,TO)
 S SOCK("S")="sock:"_$J_":"_SOCKNUM
 S SOCK("#")=SOCKNUM
 D SAVDEV^%ZISUTL(SOCK("S"))
 D LOADIO
 Q
CLSSOCK(SOCK)	;
 D SAVEIO
 D USE(.SOCK)
 D CLOSE^%ZISTCP
 D RMDEV^%ZISUTL(SOCK("S"))
 K ^TMP("MSCVRES",$J,SOCK("#"))
 D LOADIO
 Q
FROMSOCK(RETVAL,SOCK)	;
 N REMAIN,BUFFER,LEN
 D SAVEIO
 D USE(.SOCK)
 D START^MSCVRES(.RETVAL)
 S REMAIN=$$B64TOINT($RE($$READBUF(4)))
 F  D  Q:'REMAIN
 . R BUFFER#REMAIN:60
 . S LEN=$L(BUFFER)
 . I LEN D PUTBYTES(.RETVAL,BUFFER) S BUFFER="" S REMAIN=REMAIN-LEN
 D FIRST(.RETVAL)
 D LOADIO
 Q
TOSOCK(RES,SOCK)	;
 D SAVEIO
 D USE(.SOCK)
 N BYTES,BUFLEN,X,COUNT
 D TOBYTE(.BYTES,.RES)
 S COUNT=0 S X=""
 F  S X=$O(BYTES(X)) Q:X=""  S COUNT=COUNT+$L(BYTES(X))
 W $RE($$ENCODINT(COUNT,4))
 F  S X=$O(BYTES(X)) Q:X=""  W BYTES(X)
 W !
 D LOADIO
 Q
SKIPPROP(RES)	;
 Q:$$GETVAL(.RES)'=""
 F  Q:'$$NEXTPROP^MSCVRES(.RES)  D
 . D:$$GETVAL(.RES)="" SKIPPROP(.RES)
 . Q
 Q
DUMP(RES,IND)	;
 F  Q:'$$NEXTPROP^MSCVRES(.RES)  D
 . S PROPNAME=$$GETPROP^MSCVRES(.RES)
 . W IND
 . W PROPNAME
 . I $$GETVAL^MSCVRES(.RES)="" W " {",! D DUMP(.RES,IND_"  ") W IND_"}",! Q
 . W "("_$$GETVAL^MSCVRES(.RES)_")",!
 . Q
 Q
GETROOT()	;
 N NEXTNUM
        L +^TMP("MSCVRES","#"):10
 S NEXTNUM=$G(^TMP("MSCVRES","#"))+1
 S ^TMP("MSCVRES","#")=NEXTNUM
        L -^TMP("MSCVRES","#"):10
 Q $NA(^TMP("MSCVRES",$J,NEXTNUM,"DATA"))
